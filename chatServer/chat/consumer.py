import json
from channels.generic.websocket import WebsocketConsumer
from asgiref.sync import async_to_sync
from django.utils import timezone

# overall workflow of the code is as follows:
# 1. When a client connects to the WebSocket, the connect method is called. In this method, the client is added to a group (in this case, a single group named 'chat_room') and the connection is accepted.
# 2. When a client disconnects from the WebSocket, the disconnect method is called. In this method, the client is removed from the group.
# 3. When a client sends a message to the WebSocket, the receive method is called. In this method, the message is received, modified to indicate that it's from the server, and then sent to all clients in the group using the group_send method.
# 4. When a message is sent to the group with the type 'chat_message', the chat_message method is called. In this method, the message is sent back to the WebSocket client that sent the original message.


class ChatConsumer(WebsocketConsumer):
    def connect(self):
        # In a real application, you would likely want to authenticate the user and determine which chat room they are trying to join.
        # To authenticate user, you can pass user_id in websocket URL and then get the passed value in connect method using self.scope['url_route']['kwargs']['user_id'] and then authenticate the user based on the passed user_id.
        # For simplicity, we use a single chat room for all users. In a real application, you would likely want to support multiple rooms.
        # The room name can be derived from the URL or passed as a query parameter. Here, we just use a fixed room name.
        self.room_group_name = 'chat_room'
        
        # multiple clients can connect to the same room, so we use a group to manage the clients in the room. The group name is specified by self.room_group_name.

        # The group_add method is used to add the client's channel to the group. The channel name is a unique identifier for the client's connection, and it is automatically generated by Channels when the client connects.

        # if any new client came with different room name, then we can modify the value of self.room_group_name based on the passed room name and then add the client to the corresponding group. This way, we can support multiple chat rooms.

        async_to_sync(self.channel_layer.group_add)(
            self.room_group_name,
            self.channel_name,
        )
        self.accept()

    def disconnect(self, close_code):
        async_to_sync(self.channel_layer.group_discard)(
            self.room_group_name,
            self.channel_name
        )

    def receive(self, text_data):
        text_data_json = json.loads(text_data)
        message = text_data_json['message']
        message = message + "   -- reply from server" # modify the message to indicate it's from the server
        async_to_sync(self.channel_layer.group_send)(
            self.room_group_name,  # send the message to all clients in the room named 'chat_room'
            
            # The 'type' key specifies the name of the method that will be called to handle this message. In this case, it will call the chat_message method defined below.
            {
                'type': 'chat_message',

                'message': message,  
                # the actual message content that will be sent to the clients in the group. This can be any data you want to send, and it will be included in the event parameter of the chat_message method when it is called.

                'time': timezone.now().isoformat()  # you can also include additional data in the message, such as a timestamp, user information, etc. This data will also be included in the event parameter of the chat_message method when it is called.
            }

            # Like this, message can be sent to varous rooms by changing the value of self.room_group_name and also the message can be sent to specific users by using their channel names instead of group names.

            # For example, to send a message to a specific user, you can use:
            # async_to_sync(self.channel_layer.send)(
            #     user_channel_name,  # send the message to a specific user's channel
            #     { 
            #         'type': 'chat_message',
            #         'message': message    
            #     }
            # )
            # Can be seen with the help of python shell
        )

    def chat_message(self, event): 
         # This method is called when a message is sent to the group with the type 'chat_message'. The event parameter contains the message data that was sent to the group.
         
        self.send(text_data=json.dumps(event))  # This sends the message back to the WebSocket client that sent the original message. The event is converted to JSON format before being sent back to the client.